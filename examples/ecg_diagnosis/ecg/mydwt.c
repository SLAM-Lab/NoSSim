#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include "mydwt.h"

#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))

extern int fv_size, heartbeat_window, ac1, ac2, ac3, ac4, dc1, dc2, dc3, dc4, nac, ndc, wavelet, levels;

double *dbwavelet(double *conv) {
	int i,j,k,m,n,pad;
	double *F,*G,*cA,*cD,*coefs,*temp,*conv_d,*conv_sym, *Hi_D, *Lo_D;

//	double Lo_D[4] = {-0.129409522550921, 0.224143868041857, 0.836516303737469, 0.482962913144690};
//	double Hi_D[4] = {-0.482962913144690, 0.836516303737469, -0.224143868041857, -0.129409522550921};

	Hi_D = (double *)malloc(2*wavelet*sizeof(double));
	Lo_D = (double *)malloc(2*wavelet*sizeof(double));

	double rp;
	char line[80];
	FILE *fp;

	char db_num[4];
	snprintf(db_num,4,"%d",wavelet);
	char db_filters[30];
	strcpy(db_filters, "ecg_config/wavelets/db");
	strcat(db_filters, db_num);

	fp = fopen(db_filters,"r");
	fgets(line,80,fp);
	if (strcmp(line,"Hi_D\n")) printf("Error in db file.\n");

	for (i=0; i<2*wavelet; i++) {
		fgets(line,80,fp);
		Hi_D[i] = atof(line);
	}

	fgets(line,80,fp);
	if (strcmp(line,"Lo_D\n")) printf("Error in db file.\n");

	for (i=0; i<2*wavelet; i++) {
		fgets(line,80,fp);
		Lo_D[i] = atof(line);
	}
	fclose(fp);
	
//	long double Hi_D[64] = {-0.00001161463345730806, 0.00024665669989640471, -0.00243126201083021781, 0.01468104693247536223, -0.06025750138211307533, 0.17575079023627909747, -0.36750964239188882443, 0.53431793939664684601, -0.47780918166848401762, 0.12063054279310889139, 0.26669819148846507506, -0.27742159197505472656, -0.06471335722477530861, 0.24831065165186544386, -0.02466244570274563411, -0.19210235206508372019, 0.04899511934135979130, 0.14523208428704340034, -0.04440490868419939147, -0.10945611922348973122, 0.02962787670262122253, 0.08087413934560395978, -0.01410614651350997062, -0.05692632262763825529, 0.00238027133691399951, 0.03705145283184247545, 0.00414591340531883859, -0.02166282796621136347, -0.00616752458860955928, 0.01101739937087136550, 0.00541156934370804529, -0.00464921728072008843, -0.00362722467381908177, 0.00146895513638231633, 0.00196474063875566856, -0.00022116789751775934, -0.00086730586543151949, -0.00010245375053239352, 0.00030596546412335770, 0.00010539154436307172, -0.00008103678342829494, -0.00005259809613258703, 0.00001294045882413243, 0.00001824268451760185, 0.00000063617822415340, -0.00000455830975169049, -0.00000120288908485436, 0.00000075600479339252, 0.00000042859708439766, -0.00000005003362025863, -0.00000008965966656037, -0.00000001219924403736, 0.00000001104383062912, 0.00000000425042247190, -0.00000000043843879649, -0.00000000058810916834, -0.00000000008904724130, 0.00000000003263270864, 0.00000000001430918819, 0.00000000000107561069, -0.00000000000053614824, -0.00000000000016638006, -0.00000000000002000715, -0.00000000000000094210};
//	long double Lo_D[64] = {-0.00000000000000094210, 0.00000000000002000715, -0.00000000000016638006, 0.00000000000053614824, 0.00000000000107561069, -0.00000000001430918819, 0.00000000003263270864, 0.00000000008904724130, -0.00000000058810916834, 0.00000000043843879649, 0.00000000425042247190, -0.00000001104383062912, -0.00000001219924403736, 0.00000008965966656037, -0.00000005003362025863, -0.00000042859708439766, 0.00000075600479339252, 0.00000120288908485436, -0.00000455830975169049, -0.00000063617822415340, 0.00001824268451760185, -0.00001294045882413243, -0.00005259809613258703, 0.00008103678342829494, 0.00010539154436307172, -0.00030596546412335770, -0.00010245375053239352, 0.00086730586543151949, -0.00022116789751775934, -0.00196474063875566856, 0.00146895513638231633, 0.00362722467381908177, -0.00464921728072008843, -0.00541156934370804529, 0.01101739937087136550, 0.00616752458860955928, -0.02166282796621136347, -0.00414591340531883859, 0.03705145283184247545, -0.00238027133691399951, -0.05692632262763825529, 0.01410614651350997062, 0.08087413934560395978, -0.02962787670262122253, -0.10945611922348973122, 0.04440490868419939147, 0.14523208428704340034, -0.04899511934135979130, -0.19210235206508372019, 0.02466244570274563411, 0.24831065165186544386, 0.06471335722477530861, -0.27742159197505472656, -0.26669819148846507506, 0.12063054279310889139, 0.47780918166848401762, 0.53431793939664684601, 0.36750964239188882443, 0.17575079023627909747, 0.06025750138211307533, 0.01468104693247536223, 0.00243126201083021781, 0.00024665669989640471, 0.00001161463345730806};
	pad = 2*wavelet-1;
	m = heartbeat_window + 2*pad;
	n = 2*wavelet;

	F = (double *)malloc((n+m-1)*sizeof(double));
	G = (double *)malloc((n+m-1)*sizeof(double));
	cA = (double *)malloc(((n+m-1)/2)*sizeof(double));
	cD = (double *)malloc(((n+m-1)/2)*sizeof(double));
	coefs = (double *)malloc(fv_size*sizeof(double));
	temp = (double *)malloc(ndc*sizeof(double));
//	conv_d = (double *)malloc(m*sizeof(double));
	conv_sym = (double *)malloc((m)*sizeof(double));

	int iac = 0;
	int idc = 0;

	m = heartbeat_window;

   for (k=1; k<=levels; k++) {
	
	for (i=0; i<pad; i++) conv_sym[pad-1-i] = conv[i];
	for (i=0; i<m; i++) conv_sym[pad+i] = conv[i];
	for (i=0; i<pad; i++) conv_sym[m+pad+i] = conv[m-1-i];
	m = m + 2*pad;	
	
	for (i = 1; i<=(n + m -1); i++) {
    		F[i-1] = 0;
    		for (j = MAX(1,i+1-n); j<=MIN(i,m); j++) {
        		F[i-1] = F[i-1] + conv_sym[j-1]*Lo_D[i-j+1-1]; 
    		}
	}

	for (i = 1; i<=(n + m -1); i++) {
    		G[i-1] = 0;
    		for (j = MAX(1,i+1-n); j<=MIN(i,m); j++) {
        		G[i-1] = G[i-1] + conv_sym[j-1]*Hi_D[i-j+1-1]; 
    		}
	}

	for (i = pad; i<(n+m-1-pad); i++) {
		F[i-pad] = F[i];
		G[i-pad] = G[i];	
	}

	j = 0;
	for (i = 1; i<=(n + m -1-2*pad); i++) {
   		if ((i%2) == 0) {
			cA[j] = F[i-1];
			cD[j] = G[i-1];
			j = j + 1;
    		}
	}

	m = j;

//	pad = 50;
//	for (i = 0; i<j-2*pad; i++) {
//		conv[i] = cA[i+pad];
//		conv_d[i] = cD[i+pad];
//	}
//	m = j-2*pad;
	
	//free(conv_sym);
		
	if ((k==1 && ac1==1) || (k==2 && ac2==1) || (k==3 && ac3==1) || (k==4 && ac4==1)) {
		for (i = 0; i<m; i++) {
		coefs[iac+i] = cA[i];//conv[i];
		}
		iac = iac + m;
	}

	if ((k==1 && dc1==1) || (k==2 && dc2==1) || (k==3 && dc3==1) || (k==4 && dc4==1)) {
		for (i = 0; i<m; i++) {
		temp[idc + i] = cD[i];//conv_d[i];
		}
		idc = idc + m;
	}

	for (i = 0; i<j; i++) {                                           
              conv[i] = cA[i];
	}
//	if ((iac==nac) && (idc==ndc)) break;
   }

	if (idc!=0) {
		for (i=0; i<idc; i++) {
			coefs[iac + i] = temp[i];
		}
	}	

	free(F);
	free(G);
	free(cD);
	free(cA);
	free(conv_sym);
//	free(conv_d);
	free(temp);
	free(Hi_D);
	free(Lo_D);

	return(coefs);
}
